// =============================================
// TILT — SaaS CRM en un seul fichier (fullstack)
// Fonctionnalités : Auth (signup/signin/signout), Contacts, Deals, Notes,
// Dashboard (KPIs), Recherche, Import CSV (MVP), Thème & Navbar
// =============================================

use http       // Requêtes entrantes/sortantes + params + body
use db         // Persistance (SQLite par défaut) + CRUD simples
use ui         // UI déclarative (SSR + export statique)
use validate   // Validation d'entrées
use auth       // Sessions/JWT gérés par le runtime (MVP)
use policy     // Guards & rôles (RBAC léger)

// ---------------------------------------------
// 1) Schémas de données
// ---------------------------------------------

db.table("users", schema:{
  id: id,
  email: text,
  password_hash: text,
  full_name: text,
  role: text = "user",       // user | admin
  created_at: time
})

db.table("contacts", schema:{
  id: id,
  owner_id: id,               // user.id (propriétaire)
  name: text,
  email: text,
  company: text,
  phone: text,
  stage: text = "lead",       // lead | qualified | customer | churn
  created_at: time
})

db.table("deals", schema:{
  id: id,
  contact_id: id,
  owner_id: id,               // user.id
  title: text,
  value_cents: int,
  status: text = "open",      // open | won | lost
  pipeline: text = "default", // nom de pipeline
  step: text = "new",         // new | discovery | proposal | negotiation | closed
  close_date: time,
  created_at: time
})

db.table("notes", schema:{
  id: id,
  contact_id: id,
  author_id: id,
  body: text,
  created_at: time
})

// Index simples (MVP)
db.index("contacts", ["owner_id", "stage"])   // aide pour listes par owner
db.index("deals", ["owner_id", "status"])      // stats rapides

// ---------------------------------------------
// 2) RBAC & Guards
// ---------------------------------------------

policy.role "admin" { can: ["contacts:*", "deals:*", "notes:*", "users:*"] }
policy.role "user"  { can: ["contacts:read", "contacts:write", "deals:read", "deals:write", "notes:write"] }

guard require_auth() {
  if !auth.is_authenticated() { http.abort(401) }
}

guard require_perm(perm:text) {
  let me = auth.current()
  if !policy.allowed(user: me, perm: perm) { http.abort(403) }
}

// ---------------------------------------------
// 3) Auth (signup / signin / signout / me)
// ---------------------------------------------

fn api_signup() -> json {
  let b = http.request.body.json
  validate.object(b, {
    email: validate.email(),
    password: validate.text(min:8, max:200),
    full_name: validate.text(min:2, max:120)
  }) or return { ok:false, error:"invalid_input" }

  // hash par runtime (argon2/bcrypt)
  let h = auth.hash_password(b.password)
  let u = db.insert("users", { id:new_id(), email:b.email, password_hash:h, full_name:b.full_name, created_at:now() })
  let tok = auth.issue(user_id:u.id, claims:{ role:"user" })
  auth.set_session(token: tok) // Set-Cookie HttpOnly
  return { ok:true, user:{ id:u.id, email:u.email, full_name:u.full_name } }
}

fn api_signin() -> json {
  let b = http.request.body.json
  validate.object(b, { email: validate.email(), password: validate.text(min:1) }) or return { ok:false, error:"invalid_input" }
  let rows = db.select("users", { email:b.email }, limit:1)
  if len(rows)==0 { return { ok:false, error:"invalid_creds" } }
  if !auth.verify_password(b.password, rows[0].password_hash) { return { ok:false, error:"invalid_creds" } }
  let tok = auth.issue(user_id:rows[0].id, claims:{ role:rows[0].role })
  auth.set_session(token: tok)
  return { ok:true, user:{ id:rows[0].id, email:rows[0].email, full_name:rows[0].full_name, role:rows[0].role } }
}

fn api_signout() -> json { auth.clear_session(); return { ok:true } }
fn api_me() -> json { return { ok:true, user: auth.current() } }

route POST "/api/auth/signup" -> api_signup()
route POST "/api/auth/signin" -> api_signin()
route POST "/api/auth/signout" use [require_auth] -> api_signout()
route GET  "/api/auth/me"     use [require_auth] -> api_me()

// ---------------------------------------------
// 4) Contacts (CRUD, recherche)
// ---------------------------------------------

fn contacts_list() -> json {
  let me = auth.current()
  let q = http.request.query
  // Filtre par stage + recherche plein texte simple (name/email/company)
  let stage = q.stage or ""
  let search = q.q or ""
  let rows = db.select("contacts", { owner_id: me.id }, limit:500)
  let out = []
  for c in rows {
    if stage!="" && c.stage!=stage { continue }
    if search!="" && !(contains(ci:c.name, q:search) || contains(ci:c.email, q:search) || contains(ci:c.company, q:search)) { continue }
    out = out + [c]
  }
  return out
}

fn contact_create() -> json {
  let me = auth.current()
  let b = http.request.body.json
  validate.object(b, {
    name: validate.text(min:2, max:120),
    email: validate.email(optional:true),
    company: validate.text(optional:true, max:120),
    phone: validate.text(optional:true, max:40)
  }) or return { ok:false, error:"invalid_input" }

  let row = db.insert("contacts", { id:new_id(), owner_id:me.id, name:b.name, email:b.email, company:b.company, phone:b.phone, created_at:now() })
  return { ok:true, contact: row }
}

fn contact_update() -> json {
  let me = auth.current(); let id = http.params.id
  let c = db.select("contacts", { id:id }, limit:1)
  if len(c)==0 || c[0].owner_id!=me.id { http.abort(404) }
  let b = http.request.body.json
  db.update("contacts", id, { name:b.name, email:b.email, company:b.company, phone:b.phone, stage:(b.stage or c[0].stage) })
  return { ok:true }
}

fn contact_delete() -> json {
  let me = auth.current(); let id = http.params.id
  let c = db.select("contacts", { id:id }, limit:1)
  if len(c)==0 || c[0].owner_id!=me.id { http.abort(404) }
  db.delete("contacts", id); return { ok:true }
}

route GET    "/api/contacts"             use [require_auth] -> contacts_list()
route POST   "/api/contacts"             use [require_auth, require_perm("contacts:write")] -> contact_create()
route PUT    "/api/contacts/:id"         use [require_auth, require_perm("contacts:write")] -> contact_update()
route DELETE "/api/contacts/:id"         use [require_auth, require_perm("contacts:write")] -> contact_delete()

// ---------------------------------------------
// 5) Deals (CRUD, board Kanban, KPIs)
// ---------------------------------------------

fn deals_by_step() -> json {
  let me = auth.current()
  let deals = db.select("deals", { owner_id: me.id }, limit:1000)
  let steps = ["new","discovery","proposal","negotiation","closed"]
  let board = {}
  for s in steps { board[s] = [] }
  for d in deals { board[d.step] = (board[d.step] or []) + [d] }
  return board
}

fn deal_create() -> json {
  let me = auth.current(); let b = http.request.body.json
  validate.object(b, {
    contact_id: validate.text(),
    title: validate.text(min:2, max:200),
    value_cents: validate.int(min:0)
  }) or return { ok:false, error:"invalid_input" }
  let row = db.insert("deals", { id:new_id(), contact_id:b.contact_id, owner_id:me.id, title:b.title, value_cents:b.value_cents, created_at:now() })
  return { ok:true, deal: row }
}

fn deal_update() -> json {
  let me = auth.current(); let id = http.params.id
  let d = db.select("deals", { id:id }, limit:1)
  if len(d)==0 || d[0].owner_id!=me.id { http.abort(404) }
  let b = http.request.body.json
  db.update("deals", id, { title:b.title, value_cents:b.value_cents, step:(b.step or d[0].step), status:(b.status or d[0].status), close_date:b.close_date })
  return { ok:true }
}

fn deal_delete() -> json {
  let me = auth.current(); let id = http.params.id
  let d = db.select("deals", { id:id }, limit:1)
  if len(d)==0 || d[0].owner_id!=me.id { http.abort(404) }
  db.delete("deals", id); return { ok:true }
}

route GET    "/api/deals/board"          use [require_auth] -> deals_by_step()
route POST   "/api/deals"                use [require_auth, require_perm("deals:write")] -> deal_create()
route PUT    "/api/deals/:id"            use [require_auth, require_perm("deals:write")] -> deal_update()
route DELETE "/api/deals/:id"            use [require_auth, require_perm("deals:write")] -> deal_delete()

// KPIs simples (pipeline value, win rate)
fn kpis() -> json {
  let me = auth.current()
  let deals = db.select("deals", { owner_id: me.id }, limit:2000)
  let total_open = 0; let total_won = 0; let won = 0; let closed = 0
  for d in deals {
    if d.status=="open" { total_open = total_open + d.value_cents }
    if d.status=="won"  { total_won = total_won + d.value_cents; won = won + 1; closed = closed + 1 }
    if d.status=="lost" { closed = closed + 1 }
  }
  let win_rate = (closed>0) ? (won*100/closed) : 0
  return { total_open_cents: total_open, total_won_cents: total_won, win_rate: win_rate }
}

route GET "/api/kpis" use [require_auth] -> kpis()

// ---------------------------------------------
// 6) Notes (sur contact)
// ---------------------------------------------

fn note_add() -> json {
  let me = auth.current(); let b = http.request.body.json
  validate.object(b, { contact_id: validate.text(), body: validate.text(min:1, max:2000) }) or return { ok:false, error:"invalid_input" }
  let row = db.insert("notes", { id:new_id(), contact_id:b.contact_id, author_id:me.id, body:b.body, created_at:now() })
  return { ok:true, note: row }
}

fn notes_list() -> json {
  let cid = http.params.contact_id
  return db.select("notes", { contact_id: cid }, limit:500)
}

route POST "/api/notes" use [require_auth] -> note_add()
route GET  "/api/notes/:contact_id" use [require_auth] -> notes_list()

// ---------------------------------------------
// 7) UI — Auth, Dashboard, Contacts, Deals (Kanban), Settings
// ---------------------------------------------

ui.theme { mode:"auto", primary:"#6C5CE7", radius:14 }

ui.navbar {
  brand "TILT CRM"
  link "Dashboard" to "/"
  link "Contacts"  to "/contacts"
  link "Deals"     to "/deals"
  right {
    button "Sign in"  link to "/signin" when !auth.is_authenticated()
    menu label (auth.current().full_name or "") when auth.is_authenticated() {
      item "Settings" link to "/settings"
      item "Sign out" on click do_signout()
    }
  }
}

fn do_signout() -> json { let r = http.post(url:"/api/auth/signout"); return { redirect: "/signin" } }

// ---- Sign in / Sign up ----
ui.page "Sign in" path "/signin" when !auth.is_authenticated() {
  section pad=48 align="center" {
    title "Welcome back"
    form id "f_signin" on submit signin() width=420 {
      input email:text label "Email" required
      input password:text label "Password" type="password" required
      button "Sign in" variant="primary" width="100%"
      text "No account?" link "Create one" to "/signup"
    }
  }
}

fn signin() -> json {
  let f = ui.form.values
  let r = http.post(url:"/api/auth/signin", json:{ email:f.email, password:f.password })
  if r.ok && r.value.ok { return { redirect:"/" } } else { return { toast:"Invalid credentials" } }
}

ui.page "Sign up" path "/signup" when !auth.is_authenticated() {
  section pad=48 align="center" {
    title "Create your account"
    form id "f_signup" on submit signup() width=480 {
      input full_name:text label "Full name" required
      input email:text label "Email" required
      input password:text label "Password" type="password" required
      button "Create account" variant="primary" width="100%"
    }
  }
}

fn signup() -> json {
  let f = ui.form.values
  let r = http.post(url:"/api/auth/signup", json:{ full_name:f.full_name, email:f.email, password:f.password })
  if r.ok && r.value.ok { return { redirect:"/" } } else { return { toast:"Signup failed" } }
}

// ---- Dashboard ----
ui.page "Dashboard" path "/" when auth.is_authenticated() {
  let k = http.get(url:"/api/kpis")
  section pad=24 {
    grid cols=3 cols_md=1 gap=16 {
      card { title "Pipeline" text ((k.value.json.total_open_cents/100)+" € ouverts") }
      card { title "Won"      text ((k.value.json.total_won_cents/100)+" € gagnés") }
      card { title "Win rate" text (k.value.json.win_rate+" %") }
    }
  }
}

// ---- Contacts list + detail ----
ui.page "Contacts" path "/contacts" when auth.is_authenticated() {
  section pad=24 {
    form id "search" on submit search_contacts() inline {
      input q:text label "Search" placeholder "name, email, company"
      select stage:text label "Stage" options ["","lead","qualified","customer","churn"]
      button "Filter"
      button "New" on click open_new_contact()
    }

    let r = http.get(url:"/api/contacts", query: ui.form.values)
    if r.ok {
      table {
        thead ["Name","Email","Company","Stage","Actions"]
        tbody for c in r.value.json {
          tr {
            td c.name
            td c.email
            td c.company
            td badge c.stage
            td { button "Open" link to ("/contacts/"+c.id) }
          }
        }
      }
    } else { note "No contacts yet." }
  }
}

fn search_contacts() -> json { return { reload:true } }

ui.page "Contact" path "/contacts/:id" when auth.is_authenticated() {
  let id = ui.params.id
  let items = http.get(url:"/api/notes/"+id)
  section pad=24 {
    grid cols=3 cols_md=1 gap=24 {
      // Colonne 1–2 : détails
      span col=2 {
        // (MVP) simple formulaire d'édition
        form id "f_contact" on submit save_contact(id) {
          input name:text label "Name" required
          input email:text label "Email"
          input company:text label "Company"
          input phone:text label "Phone"
          select stage:text label "Stage" options ["lead","qualified","customer","churn"]
          actions { button "Save" variant="primary" }
        }
      }
      // Colonne 3 : notes
      span col=1 {
        title "Notes"
        form id "f_note" on submit add_note(id) {
          textarea body:text label "Add a note" required
          button "Add"
        }
        if items.ok {
          list for n in items.value.json { card { text n.body meta n.created_at } }
        }
      }
    }
  }
}

fn save_contact(id:text) -> json {
  let f = ui.form.values
  let r = http.put(url:("/api/contacts/"+id), json:{ name:f.name, email:f.email, company:f.company, phone:f.phone, stage:f.stage })
  if r.ok { return { toast:"Saved" } } else { return { toast:"Save error" } }
}

fn add_note(cid:text) -> json {
  let f = ui.form.values
  let r = http.post(url:"/api/notes", json:{ contact_id:cid, body:f.body })
  return r.ok ? { reload:true } : { toast:"Error" }
}

// ---- Deals board (Kanban) ----
ui.page "Deals" path "/deals" when auth.is_authenticated() {
  section pad=24 {
    actions { button "New deal" on click open_new_deal() }
    let b = http.get(url:"/api/deals/board")
    if b.ok {
      grid cols=5 cols_md=1 gap=16 {
        for step in ["new","discovery","proposal","negotiation","closed"] {
          card { title step
            list for d in (b.value.json[step] or []) {
              card { title d.title text ((d.value_cents/100)+" €")
                actions { button "Open" on click open_deal(d.id) }
              }
            }
          }
        }
      }
    }
  }
}

// Dialogs (MVP simulés via pages modales)
fn open_new_contact() -> json { return { dialog:"new_contact" } }
ui.dialog "new_contact" { form id "nc" on submit create_contact() { input name:text label "Name" required input email:text label "Email" input company:text label "Company" input phone:text label "Phone" button "Create" variant:"primary" } }
fn create_contact() -> json { let f = ui.form.values; let r = http.post(url:"/api/contacts", json:{ name:f.name, email:f.email, company:f.company, phone:f.phone }); return r.ok ? { reload:true } : { toast:"Error" } }

fn open_new_deal() -> json { return { dialog:"new_deal" } }
ui.dialog "new_deal" { form id "nd" on submit create_deal() { input contact_id:text label "Contact ID" required input title:text label "Title" required input value_cents:int label "Amount (cents)" required button "Create" variant:"primary" } }
fn create_deal() -> json { let f = ui.form.values; let r = http.post(url:"/api/deals", json:{ contact_id:f.contact_id, title:f.title, value_cents:f.value_cents }); return r.ok ? { reload:true } : { toast:"Error" } }

fn open_deal(id:text) -> json { return { route:("/deals/"+id) } }

// Settings (placeholder)
ui.page "Settings" path "/settings" when auth.is_authenticated() { section pad=24 { title "Settings" text "Profile & preferences soon." } }

// ---------------------------------------------
// 8) Utils (helpers de confort)
// ---------------------------------------------

fn contains(ci:text, q:text) -> bool { // compare case-insensitive simple
  return lower(ci).includes(lower(q))
}
